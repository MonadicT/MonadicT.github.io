<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<rss version="2.0"><channel><title>MonadicT</title><link>http://MonadicT.github.io</link><description></description><item><title>SSH tips</title><link>http://MonadicT.github.io/2014/3/01/ssh-tips/</link><pubDate>Sat, 1 Mar 2014 00:00:00 -0800</pubDate><description>&lt;p&gt;This is an introduction to &lt;code&gt;ssh&lt;/code&gt; and its cousins &lt;code&gt;scp&lt;/code&gt; and &lt;code&gt;sftp&lt;/code&gt;. My goal is to show how to use this near-universal facility conveniently.&lt;/p&gt;&lt;p&gt;&lt;code&gt;ssh&lt;/code&gt; is a &lt;em&gt;Secure Socket Layer&lt;/em&gt; application. You can think of &lt;code&gt;SSL&lt;/code&gt; as a telephone line immune to eavesdropping by others. Only you and the person on the other end of the line can hear the conversation.&lt;/p&gt;&lt;p&gt;While SSL guarantees privacy between the communicating parties, there is no promise of identity. The parties don't know who they are really talking to. Identity must be guaranteed by a trusted third-party. Without getting into the details, this is what a &lt;em&gt;Certificate Authority&lt;/em&gt; such as RSA and VeriSign guarantee. When you view a website, such as https://google.com, in your browser, the browser verifies the identity of the site you are connecting to and indicates that the identity of the website has been verified. If the verification didn't succeed, browsers alert the user of the problem.&lt;/p&gt;&lt;p&gt;When no third-party is available for identity management, the two parties must establish trust out of band. Since SSL certificates issued by CAs are expensive, most in-house usage of SSL involves &lt;em&gt;self-signed&lt;/em&gt; certificates. A &lt;em&gt;self-signed&lt;/em&gt; certificate has establishes an association between a name and a &lt;em&gt;cryptographic credentials&lt;/em&gt; also known as &lt;em&gt;keys&lt;/em&gt;. &lt;em&gt;keys&lt;/em&gt; have many magical properties and one of them is that they can't be forged. But just like the key to your house door, they should be safeguarded from thieves.&lt;/p&gt;&lt;h1&gt;Uses of ssh&lt;/h1&gt;&lt;p&gt;The most common use of &lt;code&gt;ssh&lt;/code&gt; is interacting with remote servers. However, &lt;code&gt;ssh&lt;/code&gt; is a highly flexible command and can do a lot more than just allow you to connect to a remote server.&lt;/p&gt;&lt;h2&gt;Remote server connection&lt;/h2&gt;&lt;p&gt;In this usage, you can think of &lt;em&gt;ssh&lt;/em&gt; as a secure analogue of &lt;em&gt;sh&lt;/em&gt; or &lt;em&gt;bash&lt;/em&gt;, the program which reads your commands, executes them and displays the output on the terminal or screen. You connect to a remote server using a command as shown below.&lt;/p&gt;&lt;p&gt;&lt;code&gt;
ssh userid@remote-server
&lt;/code&gt;&lt;/p&gt;&lt;p&gt;When you execute this command, &lt;em&gt;ssh&lt;/em&gt; authenticates you and then&lt;/p&gt;&lt;p&gt;When you execute &lt;code&gt;ssh server.foo&lt;/code&gt;, &lt;em&gt;ssh&lt;/em&gt; carries out these actions. Be warned that you may see a slightly different behavior depending on how things are configured.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;ssh&lt;/code&gt; client connects to the default SSL port (22) on &lt;code&gt;server.foo&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;The remote &lt;code&gt;ssh&lt;/code&gt; server accepts the connection and conveys its identity and other information to the client&lt;/li&gt;
  &lt;li&gt;If the client is connecting to the server for the very first time, and the certificate is self-signed, it displays the unique fingerprint of the server's keys and asks if the connection should be made. If you choose to continue, the server's identity is added to &lt;em&gt;known_hosts&lt;/em&gt; file. This is where you are expected to verify the fingerprint detected by &lt;em&gt;ssh&lt;/em&gt; client with what you have established out of band.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;When you are in a secure environment (is it possible?), you can probably accept any key presented by the server.&lt;/p&gt;&lt;p&gt;You may see the scary &quot;Man in the middle attack&quot; message from &lt;em&gt;ssh&lt;/em&gt;. If a server whose identity has been stored in &lt;em&gt;known_hosts&lt;/em&gt; starts using a new key, &lt;em&gt;ssh&lt;/em&gt; will detect it and flag it as a warning. The remedy is to ensure that the server is indeed using a new key and remove the old identity from &lt;em&gt;known_hosts&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;That is a superficial explanation of identity management of &lt;em&gt;ssh&lt;/em&gt; servers.&lt;/p&gt;&lt;h3&gt;SSH config file To use &lt;code&gt;ssh&lt;/code&gt; and its&lt;/h3&gt;&lt;p&gt;cousins, the command line goes something like this.&lt;/p&gt;&lt;p&gt;'''sh ssh [options] user@host [command] '''&lt;/p&gt;&lt;p&gt;/ssh/ has a very convenient facility to eliminate much typing, In =~/.ssh/config= file, you can define aliases. Here is an example entry in that file.&lt;/p&gt;&lt;p&gt;'''sh Host apollo 192.168.1.66  User alice '''&lt;/p&gt;&lt;p&gt;Now I can simply type, =ssh apollo= and it is equivalent to typing &quot;ssh alice@apollo&quot;. The value of this in being able to provide additional options, logging as different users and being able to forget actual IP addresses or host names. This also works with =scp= and =sftp= of course.&lt;/p&gt;&lt;h3&gt;Password-less Remote shell access with SSH&lt;/h3&gt;&lt;p&gt;First we generate a RSA key pair on the local system.&lt;/p&gt;&lt;p&gt;'''sh ssh-keygen -t rsa '''&lt;/p&gt;&lt;p&gt;It's highly recommended to protect your keys with a passphrase. =ssh-keygen= saves the keys as =id_rsa= and and =id_rsa.pub=. Next we copy the public key =id_rsa.pub= to the remote system(s) using scp.&lt;/p&gt;&lt;p&gt;'''sh scp ~/.ssh/id_rsa.pub user@remote-ip: '''&lt;/p&gt;&lt;p&gt;Then we login to the remote system and append =id_rsa.pub= to =~/.ssh/authorized_keys2=.&lt;/p&gt;&lt;p&gt;'''sh cat ~/id_rsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys2 chmod 700 ~/.ssh/authorized_keys2 '''&lt;/p&gt;&lt;p&gt;It's very important to set file mode to =700=. Most =sshd= will refuse to trust =authorized_keys2= if that file is accessible by others. Now log out of the remote and try =ssh user@remote-ip=. You should be prompted for the passphrase after which you should be logged into the remote system with no password!&lt;/p&gt;&lt;p&gt;Now it may not work as well as blogged here. Fortunately, =ssh= has =-v= switch to help. You can see the inner workings of ssh client and figure out what is wrong. Note that repeating this option, =-vv= will show even more information.&lt;/p&gt;&lt;p&gt;The most common reason this doesn't work is the file permission on =~/.ssh/authorized_keys2= and naming the file =~/.ssh/authorized_keys= or =~/.ssh/authorized_keys2=.&lt;/p&gt;&lt;h3&gt;Using ssh from scripts&lt;/h3&gt;&lt;p&gt;It's is always a good idea to protect keys with pass phrases. However, this poses difficulties when you need to invoke =ssh= in scripts. =ssh-agent= is the solution to being able to use keys protected with pass phrase.&lt;/p&gt;&lt;p&gt;You run 'ssh-agent' and 'ssh-add'. The latter prompts for the pass phrase of your protected key. If you attempt to run any command which needs the key, the command can check =ssh-agent= and obtain the key. So, your pass phrase is safe and keys are accessible from scripts or programs.&lt;/p&gt;&lt;p&gt;&lt;code&gt;ssh-agent&lt;/code&gt; can be accessed by remote &lt;code&gt;ssh&lt;/code&gt; connections (unless disabled explicitly). What this means is that you can maintain your private key on a single machine and still use that identity everywhere on the network. Private keys never leave the system on which they reside. &lt;code&gt;ssh-agent&lt;/code&gt; performs operations which require the private key and sends the result to the remote connection.&lt;/p&gt;&lt;p&gt;These programs have many other options to address other needs. /man/ pages are your friend.&lt;/p&gt;</description></item><item><title>Java Fork/Join Framework - an exemplar of elegant design</title><link>http://MonadicT.github.io/2014/02/26/JavaForkJoin/</link><pubDate>Wed, 26 Feb 2014 00:00:00 -0800</pubDate><description>&lt;p&gt;It's rare to see a well-crafted solution to a thorny problem. With multicore hardware becoming the norm a few years ago, we needed a way to take advantage of all those cores. In Java, we already have threads and synchronization constructs, right? What could be easier than throwing together a bunch of interfaces, classes and threads at this problem?&lt;/p&gt;&lt;p&gt;The answer is not whether it is easier or harder. The question should really be about the right way to do it. The realization of Fork/Join implementation in Java is quite an impressive piece of engineering. Engineering as in recognizing the essence of the problem and solving it just right. Of course, the credit also goes to the original work done in Cilk project at MIT.&lt;/p&gt;&lt;p&gt;I won't try to distill the contents of relevant papers in this post. You should really read Doug Lea's paper and the Cilk-5 paper would be a bonus read after that. Link to these papers are right here.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://gee.cs.oswego.edu/dl/papers/fj.pdf&quot;&gt;A Java Fork/Join Framework&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.52.2013&quot;&gt;The Implementation of the Cilk-5 Multithreaded Language&lt;/a&gt;&lt;/p&gt;&lt;p&gt;The design of work-stealing and the implementation of underlying deque is full of deep insights into the problem and clever solutions. I never thought &lt;a href=&quot;https://en.wikipedia.org/wiki/Dekker's_algorithm&quot;&gt;Dekker's algorithm&lt;/a&gt;, which provides mutual exclusion between two processes, would ever be usable in a real-world solution. I suppose, some solutions are waiting for just the right problem.&lt;/p&gt;</description></item><item><title>How to fix Wi-Fi connection issues in Ubuntu 13.04</title><link>http://MonadicT.github.io/2014/02/25/Ubuntu-Network_trouble/</link><pubDate>Tue, 25 Feb 2014 00:00:00 -0800</pubDate><description>&lt;p&gt;I have used Ubuntu for almost a decade now. I have always thought it had a pretty good chance of being the alternative to MS Windows. After the recent Windows 8 release, which definitely makes a Linux alternative all the more imperative, I find it strangely ironic that Ubuntu seems to be emulating just that. Sigh.&lt;/p&gt;&lt;p&gt;Rant over and now for a prductivity tip. When Ubuntu loses Wi-Fi connectivity, restarting network-manager or networking will not help. Reboot seems to be the only remedy after that. Here are a couple of bugs reported on this issue.&lt;/p&gt;&lt;p&gt;https://bugs.launchpad.net/ubuntu/+bug/1072518 https://bugs.launchpad.net/ubuntu/+source/dbus/+bug/1102507&lt;/p&gt;&lt;p&gt;There are many workarounds you can find on the net. However, on my laptop, what seems to work always is the following.&lt;/p&gt;&lt;p&gt;&lt;code&gt;sh
sudo modprobe -r wl
sudo modprobe wl
&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Of course, the real solution may be to start using Arch Linux or something much simpler than the Windows-wannabe Ubuntu :)&lt;/p&gt;</description></item><item><title>core.async for throttling a Clojure function</title><link>http://MonadicT.github.io/2014/02/23/rate-limited-fns/</link><pubDate>Sun, 23 Feb 2014 00:00:00 -0800</pubDate><description>&lt;h3&gt;Introduction&lt;/h3&gt;&lt;p&gt;Most of the time, we want our functions to execute as fast as possible. But sometimes, that is not quite what is desirable. For example, if we are interfacing to an external service, we may be expected to be a friendly user of it and not bombard it with requests. While it's reasonable to expect that the service will have its own throttling mechanism, it's still a technique worth knowing.&lt;/p&gt;&lt;p&gt;Throttling or rate limiting is widely used in network traffic management. &lt;a href=&quot;https://en.wikipedia.org/wiki/Token_bucket&quot;&gt;Token bucket&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Leaky_bucket&quot;&gt;Leaky bucket&lt;/a&gt; are two commonly used algorithms. We will implement a token-based rate limiter using &lt;em&gt;core.async&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;What follows is a simple Clojure macro which defines a self-governing function.&lt;/p&gt;&lt;h3&gt;How it works&lt;/h3&gt;&lt;p&gt;The function waits for a token before proceeding and the token is only issued at the specified intervals. The waiting and token granting logic is based on &lt;em&gt;core.async&lt;/em&gt; channel constructs. Each throttled function has an associated channel on which it waits to get a token. A token granter waits for an interval of time on a &lt;em&gt;timeout&lt;/em&gt; channel and sends the token on the token channel. This ensures that the function will never execute more frequently than the desired interval. The &lt;em&gt;rendezvous&lt;/em&gt; model used by &lt;em&gt;core.async&lt;/em&gt; channels ensures that the token granter waits until a prior granted token is consumed.&lt;/p&gt;&lt;p&gt;Note that the body of the function is wrapped in an anonymous function within the generated wrapper function and invoked with an &lt;em&gt;apply&lt;/em&gt;.&lt;/p&gt;&lt;h3&gt;defn-throttled&lt;/h3&gt;&lt;p&gt;Clojure code for implementing a throttled function. &lt;em&gt;defn-throttled&lt;/em&gt; is a macro resembling Clojure's &lt;em&gt;defn&lt;/em&gt; but with an additional interval specifier preceding the argument vector.&lt;/p&gt;&lt;p&gt;{% gist 9182004 %}&lt;/p&gt;</description></item><item><title>Java Reference Objects</title><link>http://MonadicT.github.io/2014/01/24/Java-References/</link><pubDate>Fri, 24 Jan 2014 00:00:00 -0800</pubDate><description>&lt;h3&gt;Introduction&lt;/h3&gt;&lt;p&gt;Perhaps the first trick of performance improvement is caching. Every programmer knows that performance of programs can be improved if somethings are cached in memory rather than recalculating or reading from disk everytime. However, balancing caching with memory needs of rest of the program is tricky. You can afford to cache a lot when demand for memory from rest of the program is small. But the cache should trim some of its entries when memory is needed by other parts of her program.&lt;/p&gt;&lt;p&gt;Consider another scenario. You have a class, say &lt;strong&gt;F&lt;/strong&gt;, you would like to extend and associate some data with it. But &lt;strong&gt;F&lt;/strong&gt; is final and you don't have the ability to change it. Ideally, you would like to have an instance of some other class &lt;strong&gt;G&lt;/strong&gt; associated with each instance of &lt;strong&gt;F&lt;/strong&gt;. You could use a hash map with &lt;strong&gt;aF&lt;/strong&gt; as key and associate &lt;strong&gt;aG&lt;/strong&gt; with it. While this works, when you don't need &lt;strong&gt;aF&lt;/strong&gt; anymore, &lt;strong&gt;aF&lt;/strong&gt; and &lt;strong&gt;aG&lt;/strong&gt; hang around in memory because they are in the hash map.&lt;/p&gt;&lt;p&gt;For our last scenario, consider an object which uses some resource. When the object is reclaimed by the garbage collector, the resource should also be freed. Ideally, we would like this to happen without tracking the object's lifetime and explicitly initiating resource cleanup. Note that &lt;em&gt;finalize&lt;/em&gt; method intended for object cleanup action is considered a nonstarter.&lt;/p&gt;&lt;p&gt;In all these cases, we would like the garbage collector to understand a bit more about the references our code keeps. The &lt;em&gt;Reference&lt;/em&gt; class and its subclasses in &lt;strong&gt;java.lang.ref&lt;/strong&gt; package provide us with the tools to interact with the garbage collector. Each of the above scenarios described above can be handled with a special type of &lt;strong&gt;Reference&lt;/strong&gt; object. The rest of the post shows some Java code to illustrate the general ideas.&lt;/p&gt;&lt;h3&gt;Building a GC-friendly cache&lt;/h3&gt;&lt;p&gt;Say, your software creates something that is expensive and we would like to improve the overall performance by caching instances of it once they are created. We might want to go about building a cache that allows us to do something like this.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Insert items into cache without worrying about the number of entries  in it.&lt;/li&gt;
  &lt;li&gt;When the program runs short of memory, discard some or all cached entries.&lt;/li&gt;
  &lt;li&gt;When a cache lookup finds a discarded entry, treat it the same as item not in cache.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;The trick to accomplishing all this without a lot of house keeping is to wrap the cached values in instances of &lt;strong&gt;java.lang.Ref.SoftReference&lt;/strong&gt;. The garbage collector has a notion of variable strength references. A normal reference to an object, also called strong reference, is one where the object is reachable from the roots of the program through a list of normal references. Instances which have strong references to them are not eligible for garbage collection. An object with a &lt;em&gt;SoftReference&lt;/em&gt; doesn't have any strong references to it and the garbage collector is free to reclaim it at its discretion.&lt;/p&gt;&lt;p&gt;The following gist illustrates how the garbage collector treats soft references to objects. Notice that a garbage collection cycle which reclaims enough memory will leave the soft references unclaimed. When memory is scarce, however, soft references will be reclaimed by garbage collection.&lt;/p&gt;&lt;p&gt;{% gist 8655216 %}&lt;/p&gt;&lt;p&gt;Here is the output produced by this code. You can see that soft references get cleared when memory is scarce.&lt;/p&gt;&lt;p&gt;{% highlight bash %} $ java SoftReferenceTest Populating cache with 1000 objects Count of objects in cache after population: 1000 Count of objects in cache after System.gc: 1000 Triggering OutOfMemoryError Count of objects in cache after OOME: 10 $ {% endhighlight bash %}&lt;/p&gt;&lt;p&gt;What would happen if we used &lt;em&gt;java.lang.ref.WeakReference&lt;/em&gt; instead of &lt;em&gt;SoftReference&lt;/em&gt;? The difference between soft and weak references is in how aggressively garbage collector reclaims them. JDK documentation for &lt;em&gt;WeakReference&lt;/em&gt; states that when garbage collector determines an object to be only weakly reachable, it will clear all weak references to that object. In contrast, when garbage collector determines an object to be softly reachable, it &lt;em&gt;may&lt;/em&gt; clear soft references to it.&lt;/p&gt;&lt;p&gt;Here is another gist illustrating the difference between &lt;em&gt;SoftReference&lt;/em&gt; and &lt;em&gt;WeakReference&lt;/em&gt;. This gist replaces all occurrences of &lt;em&gt;SoftReference&lt;/em&gt; with &lt;em&gt;WeakReference&lt;/em&gt;. From the run output, you can see that the weak references to objects don't seem to survive the process of building the hash map and System.gc() call clears them immediately.&lt;/p&gt;&lt;p&gt;{% gist 8655216 %}&lt;/p&gt;&lt;p&gt;Output from running the above gist.&lt;/p&gt;&lt;p&gt;{% highlight bash %} $ java WeakReferenceTest Populating cache with 1000 objects Count of objects in cache after population: 278 Count of objects in cache after System.gc: 10 Triggering OutOfMemoryError Count of objects in cache after OOME: 10 $ {% endhighlight bash %}&lt;/p&gt;&lt;p&gt;While $SoftReference$ looks great for building caches which automatically get smaller when memory becomes scarce, what are $WeakReferences$ good for? That is the subject of next section.&lt;/p&gt;&lt;h3&gt;Weak Hash Map&lt;/h3&gt;&lt;p&gt;The JDK documentation for $WeakReference$ says, weak references are used to build canonicalized mappings. A canonicalized mapping to an object always resolves to the same object. Consider the use case described at the beginning where we would like to associate additional information with an instance of a final class. Obviously, we should be able to retrieve the same information that we associated with the object at all times. While we could use a hash map with the object as key, all the housekeeping will have to be done by the developer.&lt;/p&gt;&lt;p&gt;This where a $WeakReference$ proves handy. Instead of storing the key of the object directly, the key is wrapped in $WeakReference$. Say we have an object instance and with it we associate some information. We can query the weak hash map with the object as the key. If the object instance gets reclaimed, the only reference to it would be its use as a key in the weak hash map. As we saw earlier, garbage collector reclaims weak references right away and the key is put on a queue. When any operations are invoked on the weak hash map, all weak references waiting in the queue are removed from the map.&lt;/p&gt;&lt;p&gt;Note that keys used in $WeakHashMap$ should not have any embedded strong references to them in the code and nor in the additional information we associated with it as the value. If the key is an interned string, the key will never become weakly referenced.&lt;/p&gt;&lt;h3&gt;Phantom Reference&lt;/h3&gt;&lt;p&gt;Now we come to the last scenario discussed in the beginning. Java objects can have a &lt;em&gt;finalize&lt;/em&gt; method in which you can perform cleanup actions. Java doesn't specify how soon the &lt;em&gt;finalize&lt;/em&gt; method will be invoked and which thread will execute the method. Joshua Bloch, author of &lt;em&gt;Effective Java&lt;/em&gt;, also points out the performance penalty of defining &lt;em&gt;finalize&lt;/em&gt; and strongly recommends avoiding it. &lt;em&gt;finalize&lt;/em&gt; seems to be one of the features of Java better left untouched. Thankfully, &lt;em&gt;PhantomReference&lt;/em&gt; is designed to address the problem of executing cleanup actions in a safe manner.&lt;/p&gt;&lt;p&gt;Using &lt;em&gt;PhantomReference&lt;/em&gt; requires a little more effort than other reference types. For starters, phantom references don't return their referent ever. That prevents you from creating strong references to an object that has been finalized. It also requires you to subclass &lt;em&gt;PhantomReference&lt;/em&gt; and maintain data needed to cleanup the referent when it is reclaimed. Phantom references must also be associated with a reference queue and a background thread is required to monitor the queue for references enqueued by garbage collector and do the cleanup actions as necessary.&lt;/p&gt;&lt;p&gt;Here is a gist which shows how phantom references should be used. Real code should probably be structured so that each object needing cleanup action should return an instance of &lt;em&gt;PhantomReference&lt;/em&gt; subclass encapsulating the cleanup data.&lt;/p&gt;&lt;p&gt;{% gist 8695437 %}&lt;/p&gt;</description></item></channel></rss>