<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="content-type" /><meta name="description" /><meta content="java gc programming" name="keywords" /><meta content="Nurullah Akkaya" name="author" /><link href="/images/favicon.ico" rel="icon" type="image/x-icon" /><link href="/images/favicon.ico" rel="shortcut icon" type="image/x-icon" /><link href="/default.css" rel="stylesheet" type="text/css" /><link href="/rss-feed" rel="alternate" title="MonadicT" type="application/rss+xml" /><link href="http://foo.com/2014/01/24/Java-References/" rel="canonical" /><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><title>Java Reference Objects</title></head><body><div id="wrap"><div id="header"><h1><a href="/">MonadicT</a></h1></div><div id="content"><div id="post"><h2 class="page-title">Java Reference Objects</h2><h3>Introduction</h3><p>Perhaps the first trick of performance improvement is caching. Every programmer knows that performance of programs can be improved if somethings are cached in memory rather than recalculating or reading from disk everytime. However, balancing caching with memory needs of rest of the program is tricky. You can afford to cache a lot when demand for memory from rest of the program is small. But the cache should trim some of its entries when memory is needed by other parts of her program.</p><p>Consider another scenario. You have a class, say <strong>F</strong>, you would like to extend and associate some data with it. But <strong>F</strong> is final and you don't have the ability to change it. Ideally, you would like to have an instance of some other class <strong>G</strong> associated with each instance of <strong>F</strong>. You could use a hash map with <strong>aF</strong> as key and associate <strong>aG</strong> with it. While this works, when you don't need <strong>aF</strong> anymore, <strong>aF</strong> and <strong>aG</strong> hang around in memory because they are in the hash map.</p><p>For our last scenario, consider an object which uses some resource. When the object is reclaimed by the garbage collector, the resource should also be freed. Ideally, we would like this to happen without tracking the object's lifetime and explicitly initiating resource cleanup. Note that <em>finalize</em> method intended for object cleanup action is considered a nonstarter.</p><p>In all these cases, we would like the garbage collector to understand a bit more about the references our code keeps. The <em>Reference</em> class and its subclasses in <strong>java.lang.ref</strong> package provide us with the tools to interact with the garbage collector. Each of the above scenarios described above can be handled with a special type of <strong>Reference</strong> object. The rest of the post shows some Java code to illustrate the general ideas.</p><h3>Building a GC-friendly cache</h3><p>Say, your software creates something that is expensive and we would like to improve the overall performance by caching instances of it once they are created. We might want to go about building a cache that allows us to do something like this.</p>
<ul>
  <li>Insert items into cache without worrying about the number of entries  in it.</li>
  <li>When the program runs short of memory, discard some or all cached entries.</li>
  <li>When a cache lookup finds a discarded entry, treat it the same as item not in cache.</li>
</ul><p>The trick to accomplishing all this without a lot of house keeping is to wrap the cached values in instances of <strong>java.lang.Ref.SoftReference</strong>. The garbage collector has a notion of variable strength references. A normal reference to an object, also called strong reference, is one where the object is reachable from the roots of the program through a list of normal references. Instances which have strong references to them are not eligible for garbage collection. An object with a <em>SoftReference</em> doesn't have any strong references to it and the garbage collector is free to reclaim it at its discretion.</p><p>The following gist illustrates how the garbage collector treats soft references to objects. Notice that a garbage collection cycle which reclaims enough memory will leave the soft references unclaimed. When memory is scarce, however, soft references will be reclaimed by garbage collection.</p><p>{% gist 8655216 %}</p><p>Here is the output produced by this code. You can see that soft references get cleared when memory is scarce.</p><p>{% highlight bash %} $ java SoftReferenceTest Populating cache with 1000 objects Count of objects in cache after population: 1000 Count of objects in cache after System.gc: 1000 Triggering OutOfMemoryError Count of objects in cache after OOME: 10 $ {% endhighlight bash %}</p><p>What would happen if we used <em>java.lang.ref.WeakReference</em> instead of <em>SoftReference</em>? The difference between soft and weak references is in how aggressively garbage collector reclaims them. JDK documentation for <em>WeakReference</em> states that when garbage collector determines an object to be only weakly reachable, it will clear all weak references to that object. In contrast, when garbage collector determines an object to be softly reachable, it <em>may</em> clear soft references to it.</p><p>Here is another gist illustrating the difference between <em>SoftReference</em> and <em>WeakReference</em>. This gist replaces all occurrences of <em>SoftReference</em> with <em>WeakReference</em>. From the run output, you can see that the weak references to objects don't seem to survive the process of building the hash map and System.gc() call clears them immediately.</p><p>{% gist 8655216 %}</p><p>Output from running the above gist.</p><p>{% highlight bash %} $ java WeakReferenceTest Populating cache with 1000 objects Count of objects in cache after population: 278 Count of objects in cache after System.gc: 10 Triggering OutOfMemoryError Count of objects in cache after OOME: 10 $ {% endhighlight bash %}</p><p>While $SoftReference$ looks great for building caches which automatically get smaller when memory becomes scarce, what are $WeakReferences$ good for? That is the subject of next section.</p><h3>Weak Hash Map</h3><p>The JDK documentation for $WeakReference$ says, weak references are used to build canonicalized mappings. A canonicalized mapping to an object always resolves to the same object. Consider the use case described at the beginning where we would like to associate additional information with an instance of a final class. Obviously, we should be able to retrieve the same information that we associated with the object at all times. While we could use a hash map with the object as key, all the housekeeping will have to be done by the developer.</p><p>This where a $WeakReference$ proves handy. Instead of storing the key of the object directly, the key is wrapped in $WeakReference$. Say we have an object instance and with it we associate some information. We can query the weak hash map with the object as the key. If the object instance gets reclaimed, the only reference to it would be its use as a key in the weak hash map. As we saw earlier, garbage collector reclaims weak references right away and the key is put on a queue. When any operations are invoked on the weak hash map, all weak references waiting in the queue are removed from the map.</p><p>Note that keys used in $WeakHashMap$ should not have any embedded strong references to them in the code and nor in the additional information we associated with it as the value. If the key is an interned string, the key will never become weakly referenced.</p><h3>Phantom Reference</h3><p>Now we come to the last scenario discussed in the beginning. Java objects can have a <em>finalize</em> method in which you can perform cleanup actions. Java doesn't specify how soon the <em>finalize</em> method will be invoked and which thread will execute the method. Joshua Bloch, author of <em>Effective Java</em>, also points out the performance penalty of defining <em>finalize</em> and strongly recommends avoiding it. <em>finalize</em> seems to be one of the features of Java better left untouched. Thankfully, <em>PhantomReference</em> is designed to address the problem of executing cleanup actions in a safe manner.</p><p>Using <em>PhantomReference</em> requires a little more effort than other reference types. For starters, phantom references don't return their referent ever. That prevents you from creating strong references to an object that has been finalized. It also requires you to subclass <em>PhantomReference</em> and maintain data needed to cleanup the referent when it is reclaimed. Phantom references must also be associated with a reference queue and a background thread is required to monitor the queue for references enqueued by garbage collector and do the cleanup actions as necessary.</p><p>Here is a gist which shows how phantom references should be used. Real code should probably be structured so that each object needing cleanup action should return an instance of <em>PhantomReference</em> subclass encapsulating the cleanup data.</p><p>{% gist 8695437 %}</p><div class="post-tags">Tags: <a href="/tags/#java">java </a><a href="/tags/#gc">gc </a><a href="/tags/#programming">programming </a></div></div><div id="related"><h3 class="random-posts">Random Posts</h3><ul class="posts"><li><span>23 Feb 2014</span><a href="/2014/02/23/rate-limited-fns/">core.async for throttling a Clojure function</a></li><li><span>24 Jan 2014</span><a href="/2014/01/24/Java-References/">Java Reference Objects</a></li><li><span>26 Feb 2014</span><a href="/2014/02/26/JavaForkJoin/">Java Fork/Join Framework - an exemplar of elegant design</a></li><li><span>01 Mar 2014</span><a href="/2014/3/01/ssh-tips/">SSH tips</a></li><li><span>25 Feb 2014</span><a href="/2014/02/25/Ubuntu-Network_trouble/">How to fix Wi-Fi connection issues in Ubuntu 13.04</a></li></ul></div></div><div id="footer"><a href="/rss-feed"> RSS Feed</a><p>&copy; 2013<a href="http://foo.com"> Foo Bar</a></p></div></div><script type="text/javascript">
//<![CDATA[
(function() {
	     var links = document.getElementsByTagName('a');
	     var query = '?';
	     for(var i = 0; i < links.length; i++) {
		     if(links[i].href.indexOf('#disqus_thread') >= 0) {
								       query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
								       }
		     }
	     document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/nakkaya/get_num_replies.js' + query + '"></' + 'script>');
	     })();
//]]>
</script></body></html>