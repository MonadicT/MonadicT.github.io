#+title: Yet Another Emacs Static-site Generator
#+summary: A static site generator implemented entirely in emacs.
#+publish-date: 2018-01-31
#+export_file_name: ../../2018/blog-site-generator.html
#+html_head: <link rel="stylesheet" type="text/css" href="style.css" />
#+tags: "static site", "emacs"
# Evaluate with: C-c C-v C-b

* Blog site generator
** Overview
Org-mode has a flexible export framework which can be leveraged to
generate Html content suitable for publishing with Jekyll, a static
site generator. This post describes the elisp package I use to
maintain my blog at [[https://MonadicT.github.io]].

Blog entries are written as a regular =.org= file. A post should have
a =#+title=, =#+summary=, =#+publish_date=, =#+tags= and
=#+export_file_name= for proper formatting and structure. The
=export_file_name= header is used by Org-mode to create the generated
Html file.

The entire site with Home, About, Tags, RSS and all the posts can be
regenerated by =Meta blog-gen-publish=, also bound to =C-c C-g=. An
individual post can be quickly examined by invoking Org export menu
(=C-c C-e=) which shows the options for processing the buffer. =C-c
C-e= C-f will generate a HTML file.

If there is =#+publish-data= header, the post will be skipped when the
site is regenerated.

A new blog entry with all the required headers can be created by
executing =blog-gen-new-post=.

** Design description
- Customizable variables describe
* Implementation
** Dependencies
Not many! =yatl= is my Elisp package for generating Html fragments
from s-expressions.

#+BEGIN_SRC elisp :results silent :exports code
(require 'cl)
(require 'yatl)
#+END_SRC

** Useful macros/functions
*** Assert utlity
#+BEGIN_SRC elisp :results silent :exports code
(defmacro assert-equal (actual expected)
  `(when (not (equal ,actual ,expected))
     (error "Actual: %s expected: %s"
            (format "%s" ',actual)
            (format "%s" ',expected))))
#+END_SRC

*** Key-value string parser
Parses key-value string of form /@key=val@key=val/.

#+BEGIN_SRC elisp :results silent
(defun blog-gen-parse-kvp(s)
  (let (res)
    (mapconcat
     (lambda (kv-str)
       (let* ((kv (split-string kv-str "="))
              (key (car kv))
              (val (cadr kv))
              (val (if (string-match "^\".*\"$" val)
                       val
                     (format "\"%s\"" val))))
         (concat key "=" val)))
     (split-string s "@" t)
     " ")))

(assert-equal (blog-gen-parse-kvp "") "")
(assert-equal (blog-gen-parse-kvp "@") "")
(assert-equal (blog-gen-parse-kvp "@a=b") "a=\"b\"")
(assert-equal (blog-gen-parse-kvp "@a=b@c=d") "a=\"b\" c=\"d\"")

#+END_SRC

#+BEGIN_SRC elisp :results silent
  (defmacro lisp (&rest forms)
    `(let ((res ,@forms))
       res))

(assert-equal (lisp 1) 1)
(assert-equal (lisp (+ 1 2 3)) 6)
(assert-equal (lisp (concat "a" "n")) "an")
(assert-equal (lisp (list 1 2 3)) '(1 2 3))

#+END_SRC

*** Parse element name
Parses element name and returns the list of element name, id, class
and attributes. Multiple class names but id must be unique. Id is
introdued by |?|, class name with |.| and attribute with |!|.

#+BEGIN_SRC elisp :results silent
  ;; Exanple names: div, div?id, div.cls1.clas2, div!k=v!k=v
  (defun blog-gen-parse-elem-name(s)
    (let ((nm-id-cls (list '() '() '() '()))
          attrs idx buf)
      (setq  idx 0)
      (mapcar
       (lambda (c)
         (cond
          ((eq c ?.) (progn
                       (setq idx 2)
                       (push c (nth idx nm-id-cls))))
          ((eq c ??) (progn
                       (if (null (cadr nm-id-cls))
                           (setq idx 1)
                         (error "ID specified again!"))))
          ((eq c ?@) (progn
                       (setq idx 3)
                       (push c (nth idx nm-id-cls))))
          ((eq idx -1) (error "Expect one of \".,+,#'"))
          (t (push c (nth idx nm-id-cls)))))
       s)
      (list (concat (reverse (car nm-id-cls)))
            (concat (reverse (cadr nm-id-cls)))
            (concat (reverse (caddr nm-id-cls)))
            (blog-gen-parse-kvp (concat (reverse (nth 3 nm-id-cls)))))))

  (assert-equal (blog-gen-parse-elem-name "div")
               '("div" "" "" ""))
  (assert-equal (blog-gen-parse-elem-name "div?id")
               '("div" "id" "" ""))
  (assert-equal (blog-gen-parse-elem-name "div?id.c1.c2")
               '("div" "id" ".c1.c2" ""))
  (assert-equal (blog-gen-parse-elem-name "div?id.c1.c2@foo=bar@baz=qux")
                 '("div" "id" ".c1.c2" "foo=\"bar\" baz=\"qux\""))

#+END_SRC

*** Return string representation
#+BEGIN_SRC elisp :results silent
   (defun blog-gen-as-string(o)
     (cond
      ((stringp o) o)
      ((numberp o) (number-to-string o))
      (t (symbol-name o))))

  (as-string 1)
#+END_SRC

*** Convert a list to HTML element
#+BEGIN_SRC elisp :results silent
  (defun blog-gen-mk-elem(o)
    (cond
     ((and (listp o) (equal (car o) 'lisp))
      (let ((res (eval (cadr o))))
        res))
     ((listp o)
      (multiple-value-bind (nm id cls attrs) (blog-gen-parse-elem-name (symbol-name (car o)))
        (let* ((attrs (seq-filter
                       (lambda (s)
                         (and (symbolp s)
                              (s-starts-with? "@" (as-string s))))
                       (cdr o)))
               (children (seq-filter
                          (lambda (s)
                            (or (listp s)
                                (not (s-starts-with? "@" (as-string s)))))
                          (cdr o)))
               (attrs-s (mapconcat #'blog-gen-parse-kvp (mapcar #'symbol-name attrs) " "))
               (children-s (mapconcat #'blog-gen-mk-elem children " ")))
          (concat
           (format "<%s" nm)
           (unless (string-empty-p id) (format " id=\"%s\"" id))
           (unless (string-empty-p cls) (format " class=\"%s\"" cls))
           (unless (string-empty-p attrs-s) (format " %s" attrs-s))
           (if (string-empty-p children-s)
               (format "/>\n")
             (format ">\n%s\n</%s>\n" children-s nm))))))
     ((symbolp o) (symbol-name o))
     ((stringp o) o)
     (t (format "%S" o))))

  (assert (string-equal (blog-gen-mk-elem "a")
                        "a"))

  (assert (string-equal (blog-gen-mk-elem '(div))
                        "<div/>\n"))

  (assert (string-equal (blog-gen-mk-elem '(div?id))
                        "<div id=\"id\"/>\n"))

  (assert (string-equal (blog-gen-mk-elem '(div?id.c1.c2))
                        "<div id=\"id\" class=\".c1.c2\"/>\n"))

  (assert (string-equal (blog-gen-mk-elem '(div?id.c1 @foo=bar@fit=bit))
                        "<div id=\"id\" class=\".c1\" foo=\"bar\" fit=\"bit\"/>\n"))

  (assert (string-equal (blog-gen-mk-elem '(lisp ))
                       nil))

  (assert (string-equal (blog-gen-mk-elem (lisp 1)) "1"))

  (let ((foo "BAR"))
    (assert (string-equal (blog-gen-mk-elem '(lisp foo))
                          "BAR")))
#+END_SRC

*** Generate HTML from list
#+BEGIN_SRC elisp :results silent
  (defmacro html(&rest forms)
    `(concat
      "<!DOCTYPE html>\n<html>\n"
      ,(mapconcat
        #'blog-gen-mk-elem
        forms
        "\n")
      "</html>"))

  (html
   (head
    (script @type=javascript @src=foo.js)
    (link @rel=stylesheet @href=https://www.w3schools.com/html/styles.css))
   (body
    "a,b"))

  (html
   (lisp (format "%S" (+ 40 2))))

  (html
   (body
    (div)
    (lisp (concat  "Hello," "world! " (current-time-string)))))
#+END_SRC

#+BEGIN_SRC elisp :results silent
    (defmacro flex-row(&rest forms)
      `(concat
        "<div class={display:flex;flex-direction:row;width:100}>"
        ,@forms
        "</div>"))

    (defmacro flex-cell(flex-by &rest forms)
      `(concat
        (format "<div style={flex: %s}" ,flex-by)
        ,@forms
        "</div>"))

    (flex-row (flex-cell 1) (flex-cell 2 org-version) (flex-cell 1))


  (defmacro html-gen(&rest forms)
    `(concat
      "<html>\n"
      ,@(mapconcat
        #'car
        forms
        "\n")
      "</html>"))

  (blog-gen-mk-elem '(html
             (head
              (script src=foo))
             (body)))

#+END_SRC

** Variables
#+BEGIN_SRC elisp :results silent
  (require 'ox-html)

   ;;; Variables and options

  (defgroup org-export-blog nil
    "Options specific to RSS export back-end."
    :tag "Org Blog"
    :group 'org-export
    :version "24.4"
    :package-version '(Org . "9.0"))

  (defcustom blog-gen-publish-url "https://MonadicT.github.io"
    "???"
    :group 'org-export-blog
    :type 'string)

  (defcustom blog-gen-title "MonadicT"
    "???"
    :group 'org-export-blog
    :type 'string)

  (defcustom blog-gen-author "Praki Prakash"
    "???"
    :group 'org-export-blog
    :type 'string)

  (defcustom blog-gen-copyright-message "Copyright &copy; 2014-%s, Praki Prakash"
    "???"
    :group 'org-export-blog
    :type 'string)

  (defcustom blog-gen-style-file "blog-style.css"
    "???"
    :group 'org-export-blog
    :type 'string)

  (defcustom blog-gen-banner-file "banner.org"
    "???"
    :group 'org-export-blog
    :type 'string)

  (defcustom blog-gen-footer-file "footer.org"
    "???"
    :group 'org-export-blog
    :type 'string)

#+END_SRC

** Inner template generator
This function is called from Org-export machinery.

#+BEGIN_SRC elisp :results silent

  (defun blog-gen-inner-template (contents info)
    (mapconcat
     (lambda (x) (format "%s" x))
     (yatl-compile
      (body
       (blog-gen-top-matter)
       (div?blog-content
        (div?blog-content-left " ")
        (div?blog-content-middle
         contents)
        (div?blog-content-right))
       (div.blog-footer
        (format blog-gen-copyright-message
                (format-time-string "%Y")))))
     ""))

#+END_SRC

** twitter-link
#+BEGIN_SRC elisp :results silent
  (defun blog-gen-twitter-link()
    "<a target=\"_new\" href=\"https://twitter.com/MonadicT\">
  <span style={background-color: white; height:48px;width:48px;border-radius:24px}></span>
  <img height=\"48px\" width=\"48px\"
     title=\"Visit my Twitter page\"
     src=\"/images/twitter.png\"/></a>")
#+END_SRC

** github-link
#+BEGIN_SRC elisp :results silent
  (defun blog-gen-github-link()
    "<a id=\"github-link\" target=\"_new\"
    href=\"https://github.com/MonadicT\"><img id=\"github-logo\"
    height=\"48\" width=\"48\" src=\"/images/github.png\"/></a>")
#+END_SRC

** Home link
#+BEGIN_SRC elisp :results silent
  (defun blog-gen-home-link()
    "<a href=\"/index.html\">Home</a>")

#+END_SRC

** Articles link
#+BEGIN_SRC elisp :results silent
  (defun blog-gen-articles-link()
    "<a href=\"/articles.html\">Articles</a>")

#+END_SRC

** About link
#+BEGIN_SRC elisp :results silent
  (defun blog-gen-about-link()
    "<a href=\"/about.html\">About</a>")

#+END_SRC

** Site links
#+BEGIN_SRC elisp :results silent
  (defun blog-gen-site-links()
    (concat
     "<div  id=\"site-links\">"
     (blog-gen-home-link)
     (blog-gen-articles-link)
     (blog-gen-about-link)
     "</div>"))
#+END_SRC

** top-matter
#+BEGIN_SRC elisp :results silent
  (defun blog-gen-top-matter()
    (concat
     "<div id=\"blog-header\" class=\"margin-row\">"
     "<div class=\"blog-margin-left\"></div>"
     (format
      "<div class=\"blog-margin-middle\" id=\"xblog-header\"><h1><div id=\"blog-title\">%s</div></h1>%s</div>"
      blog-gen-title
     (blog-gen-search-form))
     "<div class=\"blog-margin-right\">"
     "</div>"
      "</div>\n"
      "<div id=\"blog-banner\" class=\"margin-row\">"
      "<div class=\"blog-margin-left\">"
      "</div>"
      "<div class=\"blog-margin-middle\">"
      (blog-gen-site-links)
      (blog-gen-social-media-icons)
      "</div>"
      "<div class=\"blog-margin-right\"></div>"
     "</div>"))
#+END_SRC

** Search form
#+BEGIN_SRC elisp :results silent
  (defun blog-gen-search-form()
    "<div>Search <form action=\"http://www.google.com/search\" id=\"searchform\"
  method=\"get\"><div><input class=\"box\" id=\"s\" name=\"q\" type=\"text\" />
  <input name=\"sitesearch\" type=\"hidden\" value=\"http://MonadicT.github.io\" />
  </div></form></div>")
#+END_SRC

** Social media icons
#+BEGIN_SRC elisp :results silent
  (defun blog-gen-social-media-icons()
    (concat
     "<div id=\"social-media-icons\">"
     (blog-gen-twitter-link)
     (blog-gen-github-link)
     "</div>"))
#+END_SRC

** Mode implementation
#+BEGIN_SRC elisp :results silent
     ;;; Define backend

    (org-export-define-derived-backend 'blog 'html
      :menu-entry
      '(?b "Export to Blog"
           ((?b "As Blog buffer"
                (lambda (a s v b) (blog-gen-export-as-blog a s v)))
            (?f "As Blog file" (lambda (a s v b) (blog-gen-export-to-blog a s v)))
            (?o "As Blog file and open"
                (lambda (a s v b)
                  (if a (blog-gen-export-to-blog t s v)
                    (org-open-file (blog-gen-export-to-blog nil s v)))))))
      :options-alist
      '((:description "DESCRIPTION" nil nil newline)
        (:keywords "KEYWORDS" nil nil space)
        (:with-toc nil nil nil) ;; Never include HTML's toc
        )
      :filters-alist '((:filter-final-output . blog-gen-final-function))
      :translate-alist '((comment . (lambda (&rest args) ""))
                         (comment-block . (lambda (&rest args) ""))
                         (timestamp . (lambda (&rest args) ""))
                         (inner-template . blog-gen-inner-template)
                         (template . blog-gen-template)))

     ;;; Export functions

     ;;;###autoload
    (defun blog-gen-export-as-blog (&optional async subtreep visible-only)
      "Export current buffer to a blog buffer.

     Export is done in a buffer named \"*Org Blog Export*\", which will
     be displayed when `org-export-show-temporary-export-buffer' is
     non-nil."
      (interactive)
      (let ((file (buffer-file-name (buffer-base-buffer)))))
      (org-export-to-buffer 'blog "*Org Blog Export*"
        async subtreep visible-only nil nil (lambda () (text-mode))))

     ;;;###autoload
    (defun blog-gen-export-to-blog (&optional async subtreep visible-only)
      "Export current buffer to a Blog file.
     Return output file's name."
      (interactive)
      (let ((file (buffer-file-name (buffer-base-buffer)))))
      (let ((outfile (org-export-output-file-name
                      (concat "." "html") subtreep)))
        (org-export-to-file 'blog outfile async subtreep visible-only)))

     ;;;###autoload
    (defun blog-gen-publish-to-blog (plist filename pub-dir)
      "Publish an org file to Blog.

     FILENAME is the filename of the Org file to be published.  PLIST
     is the property list for the given project.  PUB-DIR is the
     publishing directory.

     Return output file name."
      (let ((bf (get-file-buffer filename)))
        (if bf
            (with-current-buffer bf
              (write-file filename))
          (find-file filename)
          (write-file filename) (kill-buffer)))
      (org-publish-org-too
       'log filename (concat "." "html") plist pub-dir))

     ;;; Main transcoding functions

    (defun blog-gen-template (contents info)
      "Return complete document string after BLOG conversion.
     CONTENTS is the transcoded contents string.  INFO is a plist
     used as a communication channel."
      (yatl-html5
       (head
        (yatl-compile-string "meta@charset=\"%s\">"
                (symbol-name org-html-coding-system))
        (title blog-gen-title)
        (yatl-compile-string
         "base@href=\"%s\""
         (if local "http://localhost:8000/" "https://MonadicT.github.io/"))
        (yatl-compile-string "meta@name=generator@content=\"%s\">" (emacs-version))
        (yatl-compile-string "meta@name=author@content=\"%s\"" blog-gen-author)
        (link@href=\"blog-style.css\"@rel=\"stylesheet\"))
       contents))

     ;;; Filters

    (defun blog-gen-final-function (contents backend info)
      "Prettify the Blog output."
      (with-temp-buffer
        (xml-mode)
        (insert contents)
        ;;(indent-region (point-min) (point-max))
        (buffer-substring-no-properties (point-min) (point-max))))

     ;;; Miscellaneous


    (provide 'ox-blog)

     ;;; ox-blog.el ends here

#+END_SRC

#+BEGIN_SRC elisp :results silent
  (require 'ox-html)
  (defun my-html-body-filter(text backend info)
    text)

  (add-to-list 'org-export-filter-body-functions
               'my-html-body-filter)
#+END_SRC

** Org-file analyzer

*** Return keywords from org-file
Returns list of OrgMode keywords from the current document.
#+BEGIN_SRC elisp :results silent
  (defun blog-gen-get-all-keywords()
    (org-element-map
        (org-element-parse-buffer 'element)
        'keyword
      (lambda (kw)
        (cons (org-element-property :key kw)
              (org-element-property :value kw)))))
#+END_SRC

#+RESULTS:
: blog-gen-get-all-keywords

*** Get keyword
Returns value of =key= or =default-value= if =key= doesn't exist in =keywords=.

#+BEGIN_SRC elisp :results silent
  (defun blog-gen-get-keyword-value(keywords key &optional default-value)
    (if-let ((kw-value (cdr (assoc-ignore-case key keywords))))
        kw-value
      default-value))
#+END_SRC

** Blog publishing
*** Blog source directory
The root directory where the source for blogs is kept.
#+BEGIN_SRC elisp :results silent
  (defcustom blog-gen-root-dir
    "~/stuff/github/MonadicT.github.io"
    "")
#+END_SRC

*** Blog posts directory
The subdirectory where =.org= files are stored.

#+BEGIN_SRC elisp :results silent
  (defcustom blog-gen-posts-dir
    "_resources/posts"
    "")
#+END_SRC

*** Publishing locally
This is a Boolean flag set to use =base= url for generated html files.
#+BEGIN_SRC elisp :results silent
(setq blog-gen-local t)
#+END_SRC
*** Extract post details
Extracts post title, summary and =publish-date= from the file. Nil is
returned if =publish-date= is not present.

#+BEGIN_SRC elisp :results silent
  (defun blog-gen-post-details (f)
    (with-temp-buffer
      (find-file f)
      (let* ((kws (blog-gen-get-all-keywords))
             (details (make-hash-table  :test #'equal)))
        (puthash "post-file" f details)
        (puthash "title" (blog-gen-get-keyword-value kws "title" "") details)
        (puthash "summary" (blog-gen-get-keyword-value kws "summary" "") details)
        (puthash "publish-date" (blog-gen-get-keyword-value kws "publish-date" nil) details)
        (puthash "export_file_name" (blog-gen-get-keyword-value kws "export_file_name" nil) details)
        (puthash "tags" (blog-gen-get-keyword-value kws "tags" "") details)
        (puthash "target" (blog-gen-get-keyword-value kws "target" "") details)
        (unless (string-match "blog-generator.org" f) (kill-buffer))
        details)))
#+END_SRC

*** Post files
Returns list of posts stored in =.org= files. =.org= files such as
=index.org=, =about.org= are not returned as posts.

#+BEGIN_SRC elisp :results silent
  (defun blog-gen-post-files()
    (let* ((posts-dir (concat blog-gen-root-dir "/" blog-gen-posts-dir))
           (org-files (directory-files posts-dir t "[a-ZA-Z0-9_-]*\\.org$"))
           (org-files
            (seq-remove
             (lambda (f)
               (or (string-match "index.org$" f)
                   (string-match "about.org$" f)
                   (string-match "sitemap.org$" f)))
             org-files)))
      (mapcar
       #'blog-gen-post-details
       org-files)))
#+END_SRC

*** Published post files
Returns published posts (posts which have =publish-date= keyword).

#+BEGIN_SRC elisp :results silent
  (defun blog-gen-published-posts (posts)
    (seq-filter (lambda (p) (gethash "publish-date" p)) posts))
#+END_SRC

*** Order post files
Orders posts by =publish-date= descending.

#+BEGIN_SRC elisp :results silent
  (defun blog-gen-order-posts(posts)
    (seq-sort (lambda (a b) (string> (gethash "publish-date" a) (gethash "publish-date" b))) posts))
#+END_SRC

*** Macro to generate =html_export= blocks
#+BEGIN_SRC elisp :results silent
  (defmacro html-export(&rest content)
    `(progn (insert "#+BEGIN_EXPORT html\n")
            (insert ,@content)
            (insert "\n#+END_EXPORT\n\n")))
#+END_SRC

*** Articles generation
Exports all =.org= post files to =.html= files.
#+BEGIN_SRC elisp :results silent
  (defun blog-gen-create-posts()
    (let ((posts (blog-gen-published-posts
                  (blog-gen-post-files))))
      (mapcar
       (lambda (post)
         (let ((post-file (gethash "post-file" post))
               (export-file-name (gethash "export_file_name" post)))
           (message (concat "exporting" post-file "to" export-file-name))
           (when export-file-name
             (with-temp-buffer
               (find-file post-file)
               (org-export-to-file 'blog export-file-name)
               (kill-buffer)))))
       posts)))
#+END_SRC
*** Articles page generation
Generates list of articles.

#+BEGIN_SRC elisp :results silent
    (defun blog-gen-create-articles()
      (with-temp-buffer
        (find-file "index.org")
        (erase-buffer)
        (insert "#+title: MonadictT\n")
        (insert "#+options: num:nil html-style:nil\n")
        (insert "* Posts\n")
        (let ((posts (blog-gen-order-posts
                      (blog-gen-published-posts
                       (blog-gen-post-files)))))
          (mapcar
           (lambda (post)
             (let* ((title (gethash "title" post))
                    (summary (gethash "summary"  post))
                    (export-file-name (gethash "export_file_name"  post))
                    (export-file-name
                     (let ((href export-file-name))
                       (while (string-match "^\\.\\./" href)
                         (setq href (substring href 3)))
                       href))
                    (publish-date (gethash "publish-date" post))
                    (l (list (make-symbol (format "a@href=\"/%s\"" export-file-name)) title)))
               (html-export
                (yatl-html-frag
                 (div.post-title
                  (eval (yatl-compile-fn l)))))
               (html-export
                (yatl-html-frag
                 (div.post-summary summary)) "\n\n")
               (html-export
                (yatl-html-frag
                 (div.post-publish-date "Published: " publish-date)) "\n")))
           posts))
        (save-buffer)
        (when (file-exists-p "../../articles.html")
          (delete-file "../../articles.html"))
        (org-export-to-file 'blog "../../articles.html")))
#+END_SRC

*** About page generation.
#+BEGIN_SRC elisp :results silent
  (defun blog-gen-create-about()
    (with-temp-buffer
      (find-file "about.org")
      (org-export-to-file 'blog "../../about.html")
      (kill-buffer)))
#+END_SRC

*** Home page generation
For now, /Home/ points to /Articles/.

#+BEGIN_SRC elisp :results silent
  (defun blog-gen-create-home()
    (copy-file "../../articles.html" "../../index.html" t))
#+END_SRC

*** Generates blog,
Function to regenerate the full site. This is bound to =C-c C-g=.

#+BEGIN_SRC elisp :results silent
      (defun blog-gen-publish(prod)
        (interactive "P")
        (if prod (setq local nil) (setq local t))
        (blog-gen-create-posts)
        (blog-gen-create-articles)
        (blog-gen-create-about)
        (blog-gen-create-home))
      (global-set-key (kbd "C-c C-g") #'blog-gen-publish)
#+END_SRC

*** Blog template
#+BEGIN_SRC elisp :results silent
  (defun blog-gen-new-post()
    (interactive)
    (insert "#+title: TBD\n
  ,#+options: toc:nil num: nil\n"))

#+END_SRC
