<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8>"/>
 <title>
MonadicT
</title>
 <base href="https://MonadicT.github.io/"/>
 <meta name="generator" content="GNU Emacs 25.3.1 (aarch64-unknown-linux-gnu, GTK+ Version 3.22.26)
 of 2017-12-09>"/>
 <meta name="author" content="Praki Prakash"/>
 <link href="blog-style.css" rel="stylesheet"/>

</head>
<body>
<div style="display:flex">
<div style="flex:2">

</div>
 <div style="flex:6">
<div>
<div class=" blog-nav">
<div id="blog-title">
MonadicT <div id="tagline">
I see dead objects!
</div>

</div>
 <div>Search <form action="http://www.google.com/search" id="searchform"
method="get"><div><input class="box" id="s" name="q" type="text" />
<input name="sitesearch" type="hidden" value="http://MonadicT.github.io" />
</div></form></div>
</div>
<div class=" blog-nav">
<div  id="site-links"><a href="/index.html">Home</a><a href="/articles.html">Articles</a><a href="/tags.html">Tags</a><a href="/about.html">About</a></div> <div id="social-media-icons"><a target="_new" href="https://twitter.com/MonadicT">
<span style={background-color: white; height:48px;width:48px;border-radius:24px}></span>
<img height="48px" width="48px"
   title="Visit my Twitter page"
   src="/images/twitter.png"/></a><a id="github-link" target="_new"
  href="https://github.com/MonadicT"><img id="github-logo"
  src="/images/github-logo.png"/></a></div>
</div>
<div style="border:1px">

</div>

<div id="outline-container-org9b2a363" class="outline-2">
<h2 id="org9b2a363">Motivation</h2>
<div class="outline-text-2" id="text-org9b2a363">
<p>
Writing HTML by hand is error-prone and just not fun. On the other
hand, a simple templating language that integrates the power of a
functional programming language with org-mode sounds like a fun
weekend exercise!
</p>
</div>

<div id="outline-container-org2376d19" class="outline-3">
<h3 id="org2376d19">Template language</h3>
<div class="outline-text-3" id="text-org2376d19">
<p>
Our template language is based on S-Expressions (Lisp syntax). We use
S-expressions to represent HTML elements. An element has a name and
optionally, a unique id, one or more class names, one or more
attributes, and child elements. In S-expression form, this is
represented as below.
</p>

<pre class="example">
(yatl-elem-name?my-id.cls1.cls2@atrr1\=val1@attr2\=val2
    (child-elem1...)
    ...)
</pre>

<p>
A template defined using this form is passed to <code>html5</code> macro which
returns a string representation of equivalent HTML.
</p>

<p>
Our template language allows mixing standard Lisp code with
templates. For most part, this mixing is achieved without any explicit
notation. A form which looks like a function or macro invocation is
evaluated as such. A list whose first element is neither a function
nor a macro is treated as an element markup. When the name of an
element clashes with a built-in or macro name, the normal processing
can be overridden by quoting it. For example, <code>(div x y)</code> is
interpreted as a Lisp expression, whereas, <code>('div (span))</code> is treated
as an element. Also, <code>(div?id)</code> is also treated as an element
definition due to the appended attributes.
</p>

<p>
Note that, we don't define any specific function or macros for various
elements. We could certainly do that if there was some reason to
eliminate duplication or error handling. This approach makes
our template language infinitely extensible.
</p>

<p>
The template below generates a well-formed HTML document.
</p>

<pre class="example">
(yatl-html5
    (head)
    (body
        (div#content
            (concat "Hello, " World!"))))
</pre>

<p>
That is all there is to our template language. It requires the user to
know the element names and attributes. But, you can write helper
functions in Lisp to address specific needs.
</p>
</div>
</div>
<div id="outline-container-org4ec533a" class="outline-3">
<h3 id="org4ec533a">Template processor</h3>
<div class="outline-text-3" id="text-org4ec533a">
</div>
<div id="outline-container-orgc365400" class="outline-4">
<h4 id="orgc365400">Standard header</h4>
<div class="outline-text-4" id="text-orgc365400">
<div class="org-src-container">
<pre><code class="src src-elisp">  <span style="color: #5F7F5F;">;;; </span><span style="color: #7F9F7F;">yatl.el --- Yet another templating language</span>

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">Copyright (C) 2017 Praki Prakash</span>

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">Author: Praki Prakash &lt;praki.prakash.gmail.com&gt;</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">Created: 2 July 2017</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">Keywords: DSL, HTML, template</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">Homepage: http://MonadicT.github.io/</span>

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">This file is not part of GNU Emacs.</span>

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">This program is free software; you can redistribute it and/or modify</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">it under the terms of the GNU General Public License as published by</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">the Free Software Foundation, either version 3 of the License, or</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">(at your option) any later version.</span>

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">This program is distributed in the hope that it will be useful,</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">GNU General Public License for more details.</span>

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">You should have received a copy of the GNU General Public License</span>
<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">along with this program.  If not, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</span>

<span style="color: #5F7F5F;">;;; </span><span style="color: #7F9F7F;">Commentary:</span>

<span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">Put a description of the package here</span>

<span style="color: #5F7F5F;">;;; </span><span style="color: #7F9F7F;">Code:</span>
</code></pre>
</div>
</div>
</div>

<div id="outline-container-orgb049655" class="outline-4">
<h4 id="orgb049655">Parsing key-value string</h4>
<div class="outline-text-4" id="text-orgb049655">
<p>
In our templating language, attributes are introduced with <code>@</code>
character, followed by the attribute name and its value. <b>=</b>
separates the name and value.
</p>

<p>
This function tries to be robust to malformed strings.
</p>
<div class="org-src-container">
<pre><code class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">yatl-parse-kvp</span>(s)
  (mapconcat
   (<span style="color: #F0DFAF; font-weight: bold;">lambda</span> (kv-str)
     (<span style="color: #F0DFAF; font-weight: bold;">let*</span> ((kv (split-string kv-str <span style="color: #CC9393;">"="</span>))
            (key (car kv))
            (val (cadr kv))
            (val (<span style="color: #F0DFAF; font-weight: bold;">or</span> val <span style="color: #CC9393;">""</span>))
            (val (<span style="color: #F0DFAF; font-weight: bold;">if</span> (string-match <span style="color: #CC9393;">"^\".*\"$"</span> val)
                     val
                   (format <span style="color: #CC9393;">"\"%s\""</span> val))))
       (concat key <span style="color: #CC9393;">"="</span> val)))
   (split-string s <span style="color: #CC9393;">"@"</span> t)
   <span style="color: #CC9393;">" "</span>))

(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (string-equal (yatl-parse-kvp <span style="color: #CC9393;">""</span>) <span style="color: #CC9393;">""</span>))
(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (string-equal (yatl-parse-kvp <span style="color: #CC9393;">"@"</span>) <span style="color: #CC9393;">""</span>))
(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (string-equal (yatl-parse-kvp <span style="color: #CC9393;">"@a"</span>) <span style="color: #CC9393;">"a=\"\""</span>))
(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (string-equal (yatl-parse-kvp <span style="color: #CC9393;">"@a="</span>) <span style="color: #CC9393;">"a=\"\""</span>))
(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (string-equal (yatl-parse-kvp <span style="color: #CC9393;">"@a=b"</span>) <span style="color: #CC9393;">"a=\"b\""</span>))
(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (string-equal (yatl-parse-kvp <span style="color: #CC9393;">"@a=b@c=d"</span>) <span style="color: #CC9393;">"a=\"b\" c=\"d\""</span>))

</code></pre>
</div>
</div>
</div>

<div id="outline-container-orgb8d4e58" class="outline-4">
<h4 id="orgb8d4e58">Parse element name</h4>
<div class="outline-text-4" id="text-orgb8d4e58">
<p>
Parses element name and returns the list of element name, id, class
and attributes. Multiple class names are allowed but id must be
unique. Id is introduced by <code>?</code>, class name with <code>.</code> and attribute with
<code>@</code>. The notation <code>?</code> is chosen as a prompt for identity (who am i?)
and @ for attribute.
</p>

<div class="org-src-container">
<pre><code class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">yatl-parse-elem-name</span>(s)
  (<span style="color: #F0DFAF; font-weight: bold;">let</span> ((nm-id-cls (list '() '() '() '()))
        attrs idx buf escape string)
    (<span style="color: #F0DFAF; font-weight: bold;">setq</span>  idx 0)
    (mapcar
     (<span style="color: #F0DFAF; font-weight: bold;">lambda</span> (c)
       (<span style="color: #F0DFAF; font-weight: bold;">cond</span>
        (escape (<span style="color: #F0DFAF; font-weight: bold;">progn</span>
                  (<span style="color: #F0DFAF; font-weight: bold;">setq</span> escape nil)
                  (<span style="color: #F0DFAF; font-weight: bold;">push</span> c (nth idx nm-id-cls))))
        ((eq c ?\\)
         (<span style="color: #F0DFAF; font-weight: bold;">setq</span> escape t))
        ((eq c ?\")
         (<span style="color: #F0DFAF; font-weight: bold;">setq</span> string (not string)))
        (string
         (<span style="color: #F0DFAF; font-weight: bold;">push</span> c (nth idx nm-id-cls)))
        ((eq c ?.) (<span style="color: #F0DFAF; font-weight: bold;">progn</span>
                     (<span style="color: #F0DFAF; font-weight: bold;">setq</span> idx 2)
                     (<span style="color: #F0DFAF; font-weight: bold;">push</span> ?  (nth idx nm-id-cls))))
        ((eq c ??) (<span style="color: #F0DFAF; font-weight: bold;">progn</span>
                     (<span style="color: #F0DFAF; font-weight: bold;">if</span> (null (cadr nm-id-cls))
                         (<span style="color: #F0DFAF; font-weight: bold;">setq</span> idx 1)
                       (<span style="color: #D0BF8F; font-weight: bold;">error</span> <span style="color: #CC9393;">"ID specified again!"</span>))))
        ((eq c ?@) (<span style="color: #F0DFAF; font-weight: bold;">progn</span>
                     (<span style="color: #F0DFAF; font-weight: bold;">setq</span> idx 3)
                     (<span style="color: #F0DFAF; font-weight: bold;">push</span> c (nth idx nm-id-cls))))
        ((eq idx -1) (<span style="color: #D0BF8F; font-weight: bold;">error</span> <span style="color: #CC9393;">"Expect one of \".,+,#'"</span>))
        (t (<span style="color: #F0DFAF; font-weight: bold;">push</span> c (nth idx nm-id-cls)))))
     s)
    (list (concat (reverse (car nm-id-cls)))
          (concat (reverse (cadr nm-id-cls)))
          (concat (reverse (caddr nm-id-cls)))
          (yatl-parse-kvp (concat (reverse (nth 3 nm-id-cls)))))))

(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (equal (yatl-parse-elem-name <span style="color: #CC9393;">"img@foo=\"http://foo.bar/baaz\""</span>)
               '(<span style="color: #CC9393;">"img"</span> <span style="color: #CC9393;">""</span> <span style="color: #CC9393;">""</span> <span style="color: #CC9393;">"foo=\"http://foo.bar/baaz\""</span>)))

(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (equal (yatl-parse-elem-name <span style="color: #CC9393;">"div"</span>)
               '(<span style="color: #CC9393;">"div"</span> <span style="color: #CC9393;">""</span> <span style="color: #CC9393;">""</span> <span style="color: #CC9393;">""</span>)))

(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (equal (yatl-parse-elem-name <span style="color: #CC9393;">"div"</span>)
               '(<span style="color: #CC9393;">"div"</span> <span style="color: #CC9393;">""</span> <span style="color: #CC9393;">""</span> <span style="color: #CC9393;">""</span>)))
(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (equal (yatl-parse-elem-name <span style="color: #CC9393;">"div?id"</span>)
               '(<span style="color: #CC9393;">"div"</span> <span style="color: #CC9393;">"id"</span> <span style="color: #CC9393;">""</span> <span style="color: #CC9393;">""</span>)))
(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (equal (yatl-parse-elem-name <span style="color: #CC9393;">"div?id.c1.c2"</span>)
               '(<span style="color: #CC9393;">"div"</span> <span style="color: #CC9393;">"id"</span> <span style="color: #CC9393;">" c1 c2"</span> <span style="color: #CC9393;">""</span>)))
(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (equal (yatl-parse-elem-name <span style="color: #CC9393;">"div?id.c1.c2@foo=bar@baz=qux"</span>)
               '(<span style="color: #CC9393;">"div"</span> <span style="color: #CC9393;">"id"</span> <span style="color: #CC9393;">" c1 c2"</span> <span style="color: #CC9393;">"foo=\"bar\" baz=\"qux\""</span>)))

</code></pre>
</div>
</div>
</div>

<div id="outline-container-org8f791ba" class="outline-4">
<h4 id="org8f791ba">Return string representation</h4>
<div class="outline-text-4" id="text-org8f791ba">
<div class="org-src-container">
<pre><code class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">as-string</span>(o)
  (<span style="color: #F0DFAF; font-weight: bold;">cond</span>
   ((stringp o) o)
   ((numberp o) (format <span style="color: #CC9393;">"%S"</span> o))
   ((symbolp o) (symbol-name o))
   (t o)))
</code></pre>
</div>
</div>
</div>
<div id="outline-container-org6272810" class="outline-4">
<h4 id="org6272810">Convert a list to HTML element</h4>
<div class="outline-text-4" id="text-org6272810">
<p>
This is the workhorse of our template processor. <code>mk-elem</code> inspects
each form in the template and processes it as follows.
</p>

<ul class="org-ul">
<li>If a list passed to <code>mk-elem</code> is assumed to be an element
specifications with the first element as the name, followed by
attribute specifications and child elements. Element's name can
include shorthand notation for id, class and attribute
specifications. Also, an element's attributes can be specified
separately from the element name by prefixing it with @. Child
elements are processed recursively with <code>mk-elem</code>. The result is
the string form of equivalent HTML.</li>
<li>If the child is an atom, its string representation is returned.</li>
</ul>

<p>
The following element specifications are all equivalent.
</p>
<pre class="example">
(div?id.cls@attr=val)
(div @id=id!class=cls!attr=val)
(div @id=id @class=cls @attr=val)
</pre>

<div class="org-src-container">
<pre><code class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">yatl-mk-elem</span>(o)
  (<span style="color: #F0DFAF; font-weight: bold;">cond</span>
   ((listp o)
    (<span style="color: #F0DFAF; font-weight: bold;">multiple-value-bind</span> (nm id cls attrs) (yatl-parse-elem-name (symbol-name (car o)))
      (<span style="color: #F0DFAF; font-weight: bold;">let*</span> ((children (cdr o))
             (children-s (mapconcat (<span style="color: #F0DFAF; font-weight: bold;">lambda</span> (x) (as-string x)) children <span style="color: #CC9393;">" "</span>)))
        (concat
         (format <span style="color: #CC9393;">"&lt;%s"</span> nm)
         (<span style="color: #F0DFAF; font-weight: bold;">unless</span> (string-empty-p id) (format <span style="color: #CC9393;">" id=\"%s\""</span> id))
         (<span style="color: #F0DFAF; font-weight: bold;">unless</span> (string-empty-p cls) (format <span style="color: #CC9393;">" class=\"%s\""</span> cls))
         (<span style="color: #F0DFAF; font-weight: bold;">unless</span> (string-empty-p attrs) (format <span style="color: #CC9393;">" %s"</span> attrs))
         (<span style="color: #F0DFAF; font-weight: bold;">if</span> (not children)
             (format <span style="color: #CC9393;">"/&gt;\n"</span>)
           (format <span style="color: #CC9393;">"&gt;\n%s\n&lt;/%s&gt;\n"</span> children-s nm))))))
   ((symbolp o) (symbol-name o))
   ((stringp o) o)
   (t (format <span style="color: #CC9393;">"%S"</span> o))))


(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (string-equal (yatl-mk-elem <span style="color: #CC9393;">"a"</span>)
                      <span style="color: #CC9393;">"a"</span>))

(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (string-equal (yatl-mk-elem '(div))
                      <span style="color: #CC9393;">"&lt;div/&gt;\n"</span>))

(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (string-equal (yatl-mk-elem '(div?id))
                      <span style="color: #CC9393;">"&lt;div id=\"id\"/&gt;\n"</span>))

(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (string-equal (yatl-mk-elem '(div?id.c1.c2))
                      <span style="color: #CC9393;">"&lt;div id=\"id\" class=\" c1 c2\"/&gt;\n"</span>))

(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (string-equal (yatl-mk-elem '(div?id.c1@foo=bar@fit=bit))
                      <span style="color: #CC9393;">"&lt;div id=\"id\" class=\" c1\" foo=\"bar\" fit=\"bit\"/&gt;\n"</span>))

(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (string-equal (yatl-mk-elem '(foo 1 2)) <span style="color: #CC9393;">"&lt;foo&gt;\n1 2\n&lt;/foo&gt;\n"</span>))

(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (string-equal (yatl-mk-elem '(img@src=\"http://example.com/images/fubar.png\"))
                      <span style="color: #CC9393;">"&lt;img src=\"http://example.com/images/fubar.png\"/&gt;\n"</span>))
</code></pre>
</div>
</div>
</div>

<div id="outline-container-org7b59304" class="outline-4">
<h4 id="org7b59304">Template processor</h4>
<div class="outline-text-4" id="text-org7b59304">
<p>
This is the implementation section of the template processor. This
file can be processed using org-babel-tangle to produce a
<code>~/.emacs.d/yatl.el</code> file. The package is named <code>yatl</code> for "Yet
Another Template Language" and <code>(require 'yatl)</code> to access it.
</p>
</div>

<ul class="org-ul">
<li><a id="orgfbee8b8"></a>yatl-compile-fn<br />
<div class="outline-text-5" id="text-orgfbee8b8">
<p>
This is a helper function to examine each form and turn it into a form
that can be passed to <code>yatl-mk-elem</code>. What we want is the ability to mix
lisp code with our element markup code. We want this to be as seamless
as possible. Consider the following example.
</p>

<pre class="example">
(html5 (head) (body (concat "Hello, " "World!")))
</pre>

<p>
<code>html5</code> will be defined as a macro later. We need to treat <code>head</code>,
<code>body</code> as HTML elements and <code>concat</code> as a built-in function. For
convenience, we would also want to be able to write our own functions
and macros, if we so desire. To meet this requirement, we need a way
to work with evaluated Lisp forms and modify it so that it can be
evaluated to yield valid HTML content. A Lisp macro doesn't evaluate
its arguments and is the perfect tool for this job. (Unfortunately,
elisp has no support for reader macros which would made this task
simpler.)
</p>

<p>
<code>yatl-compile-fn</code> looks for forms which might be function or macro
invocations. It calls itself on the arguments and returns a
potentially modified form. If the list is neither a function nor a
macro invocation, then it is an element definition in our notation
which is handled by invoking <code>yatl-mk-elem</code>.
</p>

<p>
The ability to mix Lisp code with our element description works, we
need the ability to override the automatic recognition of function
application. Consider the need to describe a 'div' element. <code>div</code> also
happens to be Lisp function. When we want to use <code>div</code> as element, we
override its meaning by writing it as <code>'div</code>.
</p>

<div class="org-src-container">
<pre><code class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">yatl-compile-fn</span> (form)
  (<span style="color: #F0DFAF; font-weight: bold;">cond</span>
   ((symbolp form) form)
   ((numberp form) form)
   ((stringp form) form)
   ((listp form)
    (<span style="color: #F0DFAF; font-weight: bold;">cond</span>
     <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">quoted form</span>
     ((<span style="color: #F0DFAF; font-weight: bold;">and</span> (car form) (listp (car form)) (eq (caar form) 'quote))
      (yatl-mk-elem `(,(cadar form) ,@(mapcar #'yatl-compile-fn (cdr form)))))
     <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">lambda form</span>
     ((<span style="color: #F0DFAF; font-weight: bold;">and</span> (eq (car form) 'lambda))
      (<span style="color: #F0DFAF; font-weight: bold;">let*</span> ((args-list (cadr form))
             (forms (cddr form))
             (new-forms (mapcar #'yatl-compile-fn forms)))
        `(<span style="color: #F0DFAF; font-weight: bold;">lambda</span> ,args-list ,@new-forms)))
     <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">special form</span>
     ((<span style="color: #F0DFAF; font-weight: bold;">and</span> (special-form-p (car form)))
      <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">cond, let,let*, require special handling</span>
      (<span style="color: #F0DFAF; font-weight: bold;">cond</span>
       ((eq (car form) 'let)
        (<span style="color: #F0DFAF; font-weight: bold;">let*</span> ((bindings (cadr form))
               (forms (cddr form))
               (new-bindings (mapcar
                              (<span style="color: #F0DFAF; font-weight: bold;">lambda</span> (binding)
                                (<span style="color: #F0DFAF; font-weight: bold;">if</span> (listp binding)
                                    `(,(car binding) ,(yatl-compile-fn (cadr binding)))
                                  binding))
                              bindings))
               (new-forms (mapcar #'yatl-compile-fn forms)))
          `(<span style="color: #F0DFAF; font-weight: bold;">let</span> ,new-bindings ,@new-forms)))
       (t `(,(car form) ,@(mapcar #'yatl-compile-fn (cdr form))))))
     <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">macro defn</span>
     ((<span style="color: #F0DFAF; font-weight: bold;">and</span> (macrop (car form)))
      (eval `(,(car form) ,@(mapcar #'yatl-compile-fn (cdr form)))))
     <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">function</span>
     ((<span style="color: #F0DFAF; font-weight: bold;">and</span> (symbolp (car form)) (fboundp (car form)))
      `(,(car form) ,@(mapcar #'yatl-compile-fn (cdr form))))
     <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">List of lists. Don't process?</span>
     ((not (symbolp (car form)))
      form)
     (t `(yatl-mk-elem (list ',(car form) ,@(mapcar #'yatl-compile-fn (cdr form)))))))
   (t (<span style="color: #F0DFAF; font-weight: bold;">throw</span> '<span style="color: #BFEBBF;">Unhandled</span> form))))
</code></pre>
</div>
</div>
</li>

<li><a id="org66e1a6e"></a>yatl-Compile macro<br />
<div class="outline-text-5" id="text-org66e1a6e">
<p>
A macro which applies <code>yatl-compile-fn</code> to its arguments and concatenates the
values returned. This must be a macro as the S-expressions can't be
evaluated directly.
</p>

<p>
That is our <del>first</del> second attempt at designing this template language
and its processor. Stay tuned for future posts where I will show its
use with org-mode.
</p>

<div class="org-src-container">
<pre><code class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defmacro</span> <span style="color: #93E0E3;">yatl-compile</span>(<span style="color: #7CB8BB;">&amp;rest</span> forms)
  `(list
    ,@(mapcar
       #'yatl-compile-fn
       forms)))

(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (equal (<span style="color: #F0DFAF; font-weight: bold;">yatl-compile</span> 1) '(1)))
(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (equal (<span style="color: #F0DFAF; font-weight: bold;">yatl-compile</span> (+ 1 2)) '(3)))
(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (equal (<span style="color: #F0DFAF; font-weight: bold;">yatl-compile</span> (span <span style="color: #CC9393;">"foo"</span>)) '(<span style="color: #CC9393;">"&lt;span&gt;\nfoo\n&lt;/span&gt;\n"</span>)))
(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (equal (<span style="color: #F0DFAF; font-weight: bold;">yatl-compile</span> (span)) '(<span style="color: #CC9393;">"&lt;span/&gt;\n"</span>)))
(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (equal (<span style="color: #F0DFAF; font-weight: bold;">yatl-compile</span> (<span style="color: #F0DFAF; font-weight: bold;">if</span> t (span))) '(<span style="color: #CC9393;">"&lt;span/&gt;\n"</span>)))
(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (equal (<span style="color: #F0DFAF; font-weight: bold;">yatl-compile</span> (div (span))) '(<span style="color: #CC9393;">"&lt;div&gt;\n&lt;span/&gt;\n\n&lt;/div&gt;\n"</span>)))

(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (equal (<span style="color: #F0DFAF; font-weight: bold;">yatl-compile</span> (<span style="color: #F0DFAF; font-weight: bold;">let</span> (x) x)) '(nil)))
(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (equal (<span style="color: #F0DFAF; font-weight: bold;">yatl-compile</span> (<span style="color: #F0DFAF; font-weight: bold;">let</span> ((x 1) (y 2)) (+ x y))) '(3)))
(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (equal (<span style="color: #F0DFAF; font-weight: bold;">yatl-compile</span> (<span style="color: #F0DFAF; font-weight: bold;">let</span> ((x 1) (y 2) (z (span <span style="color: #CC9393;">"foobar"</span>))) z))
               '(<span style="color: #CC9393;">"&lt;span&gt;\nfoobar\n&lt;/span&gt;\n"</span>)))
(<span style="color: #F0DFAF; font-weight: bold;">assert</span> (equal (<span style="color: #F0DFAF; font-weight: bold;">yatl-compile</span> (img?id@src=\"http://foo.bar/baaz.jpg\"))
               '(<span style="color: #CC9393;">"&lt;img id=\"id\" src=\"http://foo.bar/baaz.jpg\"/&gt;\n"</span>)))
</code></pre>
</div>
</div>
</li>

<li><a id="orgbc2b7cb"></a>yatl-compile-string<br />
<div class="outline-text-5" id="text-orgbc2b7cb">
<p>
Occasionally, we need to create forms at run-time and <code>yatl-compile</code>
macro doesn't evaluate its arguments. This function provides an escape
hatch for these cases.
</p>

<div class="org-src-container">
<pre><code class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">yatl-compile-string</span>(fmt <span style="color: #7CB8BB;">&amp;rest</span> args)
  (<span style="color: #F0DFAF; font-weight: bold;">let</span> ((s (apply #'format fmt args)))
    (eval (yatl-compile-fn (list (make-symbol s))))))
</code></pre>
</div>
</div>
</li>

<li><a id="org7a65300"></a>html5 macro<br />
<div class="outline-text-5" id="text-org7a65300">
<p>
Macro which wraps the yatl-compiled forms in HTML5 boilerplate.
</p>

<div class="org-src-container">
<pre><code class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defmacro</span> <span style="color: #93E0E3;">yatl-html5</span>(<span style="color: #7CB8BB;">&amp;rest</span> forms)
  `(concat
    <span style="color: #CC9393;">"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n"</span>
    (mapconcat (<span style="color: #F0DFAF; font-weight: bold;">lambda</span> (x) (format <span style="color: #CC9393;">"%s"</span> x)) (<span style="color: #F0DFAF; font-weight: bold;">yatl-compile</span> ,@forms) <span style="color: #CC9393;">""</span>)
    <span style="color: #CC9393;">"&lt;/html&gt;"</span>))
</code></pre>
</div>
</div>
</li>

<li><a id="orgbc9c038"></a>HTML fragment generator<br />
<div class="outline-text-5" id="text-orgbc9c038">
<div class="org-src-container">
<pre><code class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defmacro</span> <span style="color: #93E0E3;">yatl-html-frag</span>(<span style="color: #7CB8BB;">&amp;rest</span> forms)
  `(concat
    (mapconcat (<span style="color: #F0DFAF; font-weight: bold;">lambda</span> (x) (format <span style="color: #CC9393;">"%s"</span> x)) (<span style="color: #F0DFAF; font-weight: bold;">yatl-compile</span> ,@forms) <span style="color: #CC9393;">""</span>)))
</code></pre>
</div>
</div>
</li>
<li><a id="orgc152bb6"></a>yatl-Compile macro tests<br />
<div class="outline-text-5" id="text-orgc152bb6">
<p>
We make sure our <code>yatl-html5</code> works as expected when we mix our notation
with Lisp function and macros. Let's define a few test fixtures.
</p>

<div class="org-src-container">
<pre><code class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defmacro</span> <span style="color: #93E0E3;">test-macro</span> (<span style="color: #7CB8BB;">&amp;rest</span> forms)
  `(concat
    <span style="color: #CC9393;">"&lt;div style=\"{display:flex}\"&gt;"</span>
    ,@forms
    <span style="color: #CC9393;">"&lt;/div&gt;"</span>))

(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">test-function</span> (<span style="color: #7CB8BB;">&amp;rest</span> forms)
  (apply #'concat forms))

(<span style="color: #F0DFAF; font-weight: bold;">assert</span>
 (equal
  (<span style="color: #F0DFAF; font-weight: bold;">yatl-html5</span>)
  <span style="color: #CC9393;">"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;/html&gt;"</span>))

(<span style="color: #F0DFAF; font-weight: bold;">assert</span>
 (equal
  (<span style="color: #F0DFAF; font-weight: bold;">yatl-html5</span> (head) (body))
  <span style="color: #CC9393;">"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head/&gt;\n&lt;body/&gt;\n&lt;/html&gt;"</span>))

(<span style="color: #F0DFAF; font-weight: bold;">assert</span>
 (equal
  (<span style="color: #F0DFAF; font-weight: bold;">yatl-html5</span> (body (test-function <span style="color: #CC9393;">"foo"</span> <span style="color: #CC9393;">"bar"</span>)))
  <span style="color: #CC9393;">"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\nfoobar\n&lt;/body&gt;\n&lt;/html&gt;"</span>))

(<span style="color: #F0DFAF; font-weight: bold;">assert</span>
 (equal
  (<span style="color: #F0DFAF; font-weight: bold;">yatl-html5</span> (body (<span style="color: #F0DFAF; font-weight: bold;">test-macro</span> (<span style="color: #F0DFAF; font-weight: bold;">test-macro</span>))))
  <span style="color: #CC9393;">"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n&lt;div style=\"{display:flex}\"&gt;&lt;div style=\"{display:flex}\"&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;"</span>))

(<span style="color: #F0DFAF; font-weight: bold;">assert</span>
 (equal
  (<span style="color: #F0DFAF; font-weight: bold;">yatl-html5</span> (head))
  <span style="color: #CC9393;">"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head/&gt;\n&lt;/html&gt;"</span>))

(<span style="color: #F0DFAF; font-weight: bold;">assert</span>
 (equal
  (<span style="color: #F0DFAF; font-weight: bold;">yatl-html5</span> (head (style)))
  <span style="color: #CC9393;">"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;style/&gt;\n\n&lt;/head&gt;\n&lt;/html&gt;"</span>))

(<span style="color: #F0DFAF; font-weight: bold;">assert</span>
 (equal
  (<span style="color: #F0DFAF; font-weight: bold;">yatl-html5</span> (<span style="color: #F0DFAF; font-weight: bold;">let</span> ((l '((a . 1) (b . 2)))) <span style="color: #CC9393;">"foo"</span>))
  <span style="color: #CC9393;">"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\nfoo&lt;/html&gt;"</span>))
</code></pre>
</div>
</div>
</li>

<li><a id="org08bcb8f"></a>Provide our module<br />
<div class="outline-text-5" id="text-org08bcb8f">
<p>
Make this package available.
</p>

<div class="org-src-container">
<pre><code class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">provide</span> '<span style="color: #BFEBBF;">yatl</span>)
<span style="color: #5F7F5F;">;;; </span><span style="color: #7F9F7F;">yatl.el ends here</span>
</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>

</div>

</div>
 <div style="flex:2">

</div>
 <div class=" blog-footer">
Copyright &copy; 2014-2018, Praki Prakash
</div>

</div>

</body>
</html>
